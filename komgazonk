#!/usr/bin/env python

# LysKOM gazonk client

# (C) 2002 Ragnar Ouchterlony. Released under GPL.

import kom
import time
import select
import string
import os
import os.path
import re
from komgazonk_config import *
import cPickle
import random

CLIENTNAME="komgazonk"
VERSION="0.1.0"

INVISIBLE = 1

MAX_ENTRIES_GUESS_LIST = 200

wrong_guess_list = ["Fel, fel, fel, fel!", \
                    "Trodde du verkligen att det skulle vara rätt?", \
                    "Om du läser ledtrådarna först går det nog bättre.", \
                    "En daggmask hade kommit på något bättre än det där."]
class Gazonk:
    re_auto_reply = re.compile("^Auto-reply:", re.IGNORECASE)
    re_ny_gazonk = re.compile("^ny gazonk", re.IGNORECASE)
    re_losenord_a = re.compile("^lösenord", re.IGNORECASE)
    re_losenord_b = re.compile("^[Ll][Öö][Ss][Ee][Nn][Oo][Rr][Dd] *([" + GAZ_PW_CHARS + \
                               "]{1," + str(GAZ_PW_LENGTH) + "}) *$")
    re_gissning = re.compile("^[" + GAZ_PW_CHARS + "]{1," + str(GAZ_PW_LENGTH) + "}$")
    re_ledtrad = re.compile("^ledtråd *(.*) *$", re.IGNORECASE)
    re_byt_ledtrad = re.compile("^byt ledtråd *([0-9]+) *(.*) *$", re.IGNORECASE)
    re_gissa = re.compile("^gissa *(.*) *$")
    re_vem = re.compile("^vem", re.IGNORECASE)
    re_visa = re.compile("^visa", re.IGNORECASE)
    re_nasta = re.compile("^nästa", re.IGNORECASE)

    def __init__(self):
        self.monthly = MonthlyStats()
        self.current_guesses = GuessDB()
        self.reset()
        self.monthly.reset()

    def reset(self):
        self.person_no = -1
        self.password = "";
        self.clues = []
        self.current_clue = -1
        self.time_last_action = -1
        self.warnings_sent = 0
        self.last_text_no = -1
        self.current_guesses.reset()
        self.per_clue_guesses = []

    def monthly_reset(self):
        self.all_guesses.reset()

    def set_last_action(self):
        self.time_last_action = time.time()

    def print_me(self):
        gaz_name = "no name"
        if self.person_no > 0:
            gaz_name = kom.ReqGetUconfStat(conn, self.person_no).response().name
        print "Gazonk: %s" % gaz_name
        print "Password: %s" % self.password
        print "Clues: " + str(self.clues)
        print "Current clue: %d" % self.current_clue
        print "Time for last action: " + str(self.time_last_action)
        print "Num warnings sent: %d" % self.warnings_sent

    def create_guess_list_string(self, max_nr = MAX_ENTRIES_GUESS_LIST):
        message = ""
        i = 0
        for gdb in self.per_clue_guesses:
            i += 1
            message += "Gissningar för ledtråd %d:\n" % i
            message += "----------------------------\n"
            message += "%d. %s" % (i, self.clues[i-1])
            message += "\n----------------------------\n"
            message += gdb.create_string(MAX_ENTRIES_GUESS_LIST)
            message += "\n"

        message += "Alla gissningar:\n"
        message += "----------------------------\n"
        message += self.current_guesses.create_string(MAX_ENTRIES_GUESS_LIST)
        return message

    def create_clue_string(self, disp_all):
        clues = self.clues
        if disp_all == 0:
            if self.current_clue == -1:
                return "Inga ledtrådar att visa\n"
            clues = clues[:(self.current_clue+1)]
        elif disp_all == 2:
            if self.current_clue == -1:
                return "Inga ledtrådar att visa\n"
            clues = clues[(self.current_clue+1):]

        if len(clues) == 0:
            return "Inga ledtrådar att visa\n"

        clue_string = ""
        i = 0
        if disp_all == 2:
            i = self.current_clue+1
        for c in clues:
            i += 1
            clue_string += str(i) + ". " + c + "\n"
        return clue_string

    def send_end_of_round_message(self, subject, message):
        message += "\n\nLösenordet var '%s'.\n\n" % self.password
        message += "Givna ledtrådar:\n"
        message += self.create_clue_string(0)
        message += "\nIcke givna ledtrådar:\n"
        message += self.create_clue_string(2) + "\n"
        message += self.create_guess_list_string(MAX_ENTRIES_GUESS_LIST)
        self.send_letter(subject, message, GAZONK_CONF, 0, 0)

    def send_next_clue_letter(self, dont_increase = 0):
        new = 0
        if dont_increase == 0:
            self.current_clue += 1
            self.per_clue_guesses.append( GuessDB() )
            if self.current_clue == 0:
                new = 1

        gaz_name = kom.ReqGetUconfStat(conn, self.person_no).response().name
        mess_subject = "<Person %d: %s> gazonkar" % (self.person_no, gaz_name)
        mess_text = self.create_clue_string(0)
        self.send_letter(mess_subject, mess_text, GAZONK_CONF, new, 0)

    def send_clue_message(self, recipient, disp_all):
        send_string = "Ledtrådar:\n\n"
        send_string += self.create_clue_string(disp_all)

        send_message(send_string, recipient)

    def send_letter(self, subject, message, recipient, new, person):
        recipient_name = kom.ReqGetUconfStat(conn, recipient).response().name
        log("%s: Brev till %s:" % (get_date_and_time(), recipient_name))
        log(indent(message, 2) + "\n")

        misc_info = kom.CookedMiscInfo()
        rec = kom.MIRecipient(kom.MIR_TO, recipient)
        misc_info.recipient_list.append(rec)

        if new == 0 and person == 0 and self.last_text_no > 0:
            try:
                ts = conn.textstats[self.last_text_no]
                mic = kom.MICommentTo(kom.MIC_COMMENT, self.last_text_no)
                misc_info.comment_to_list.append(mic)
            except:
                log("Old text number %d not found" % self.last_text_no)

        send_text = subject + "\n" + message
        text_no = kom.ReqCreateText(conn, send_text, misc_info, []).response()
        if person == 0:
            self.last_text_no = text_no

    def check_clues(self):
        log("Checking if we should send out clues or warnings.")

        # Skall vi börja en ny omgång?
        if len(self.password) > 0 and \
           len(self.clues) > 0 and \
           self.current_clue == -1:
            self.send_next_clue_letter()
            self.set_last_action()
            self.warnings_sent = 0
            return

        current_time = time.time()
        # Skall vi skicka ut en ny ledtråd?
        if self.current_clue > -1 and \
           len(self.clues) > self.current_clue + 1 and \
           current_time - self.time_last_action > GAZONK_CLUE_TIME:
            self.send_next_clue_letter()
            self.set_last_action()
            self.warnings_sent = 0
            return

        # Dags att skicka ut påminnelse tro?
        if self.person_no > 0 and \
           ((len(self.password) == 0 and len(self.clues) == 0) or \
            len(self.clues) <= self.current_clue + 1) and \
           current_time - self.time_last_action > \
           GAZONK_REMEMBER_TIME * (self.warnings_sent + 1):
            self.warnings_sent += 1

            # Har vi skickat tillräckligt med varningar nu?
            if self.warnings_sent > GAZ_MAX_WARNINGS:
                my_name = kom.ReqGetUconfStat(conn, KOMPERSON).response().name
                gaz_name = kom.ReqGetUconfStat(conn, self.person_no).response().name
                self.send_letter("Du är inte längre gazonk!",
                                 "Du har inte lyssnat på varningarna och blir därmed \n" + \
                                 "fråntagen din gazonktitel!",
                                 self.person_no, 1, 1)
                subject = "<Person %d: %s> ej längre gazonk!" % (self.person_no, gaz_name)
                message = "Vem som helst kan nu bli gazonk. Skicka bara 'ny gazonk'" + \
                          "\ni ett meddelande till <Person %d: %s>" % (KOMPERSON, my_name)
                if len(self.password) > 0 and len(self.clues) > 0:
                    self.send_end_of_round_message(subject, message)
                else:
                    self.send_letter(subject, message, GAZONK_CONF, 0, 0)
                self.reset()
                return

            # Skicka varningen
            message = "Det finns inte tillräckligt med ledtrådar i ledtrådskön."
            future_warnings = GAZ_MAX_WARNINGS - self.warnings_sent
            if self.warnings_sent >= 2:
                message += "\n\nOm ledtrådskön ej fyllts på efter %d fler varningar \n" % \
                           future_warnings
                message += "kommer din gazonk-titel att fråntas dig!"
            self.send_letter("Detta är en påminnelse om att du är gazonk!",
                             message, self.person_no, 1, 1)
            return

    def parse_message(self, msg, c):
        sender_name = kom.ReqGetUconfStat(conn, msg.sender).response().name
        log("%s: Meddelande (%d) från %s:" % (get_date_and_time(), msg.recipient, sender_name))
        log(indent(msg.message, 2) + "\n")

        # Svara ej på automatsvar.
        m = Gazonk.re_auto_reply.search(msg.message)
        if m:
            return

        # Saker som endast kan göras om ingen gazonk finns:
        if self.person_no == -1:
            # Är detta en request för ny gazonk?
            m = Gazonk.re_ny_gazonk.search(msg.message)
            if m:
                self.reset()
                self.person_no = msg.sender
                self.set_last_action()
                send_message("Du är nu ny gazonk!", msg.sender)
                return

        # Saker som endast nuvarande gazonk får göra:
        if self.person_no == msg.sender:
            # Skall vi sätta ett nytt lösenord
            ma = Gazonk.re_losenord_a.search(msg.message)
            mb = Gazonk.re_losenord_b.match(msg.message)
            # Vi får enbart sätta lösenordet om omgången ej är startad än.
            # Skicka tillbaka lösenordet istället.
            if ma and self.current_clue > -1:
                send_message("Har du blivit senil? Nuvarande lösenord är '%s'." % \
                             self.password, \
                             msg.sender)
                return
            elif ma and mb:
                self.password = mb.group(1)
                self.clues = []
                self.current_clue = -1
                self.time_last_action = -1
                self.warnings_sent = 0
                self.last_text_no = 0
                self.set_last_action()
                send_message("Nytt lösenord är '%s'." % self.password, msg.sender)
                return
            elif ma:
                send_message("Ditt lösenord godkändes ej.\n\n" + \
                             "Ett lösenord skall enbart innehålla bokstäverna\n" + \
                             "a-z, å, ä, ö, samt vara mellan 1 och %d bokstäver långt." % \
                             GAZ_PW_LENGTH, \
                             msg.sender)
                return

            # Skall vi lägga till en ny ledtråd?
            m = Gazonk.re_ledtrad.match(msg.message)
            if m and len(self.password) == 0:
                send_message("Skriv in lösenord innan du skriver in ledtrådar.", msg.sender)
                return
            elif m:
                clue = m.group(1)
                if len(clue) != 0:
                    self.clues.append(m.group(1))
                self.send_clue_message(msg.sender, 1)
                return

            # Skall byta ut en ledtråd?
            m = Gazonk.re_byt_ledtrad.match(msg.message)
            if m and len(self.password) == 0:
                send_message("Skriv in lösenord innan du skriver in ledtrådar.", msg.sender)
                return
            elif m:
                nr = int(m.group(1))
                clue = m.group(2)
                if nr > len(self.clues):
                    send_message("Ledtrådsnumret finns inte.", msg.sender)
                    return
                elif nr > 0:
                    self.clues[nr-1] = clue
                    send_message("Ledtråd %d byttes ut till: %s" % (nr, clue), msg.sender)
                    if nr <= self.current_clue + 1:
                        self.send_next_clue_letter(1)
                    return

        # Saker som alla får göra:

        # Vem är gazonk?
        m = Gazonk.re_vem.search(msg.message)
        if m:
            if self.person_no > 0:
                gaz_name = kom.ReqGetUconfStat(conn, self.person_no).response().name
                send_message("<Person %d: %s> är gazonk!" % (self.person_no, gaz_name), \
                             msg.sender)
            else:
                send_message("Ingen person är gazonk just nu!", msg.sender)
            return

        # Visa nuvarande ledtrådar
        m = Gazonk.re_visa.search(msg.message)
        if m:
            if self.current_clue == -1:
                send_message("Ingen gazonk-omgång pågår just nu.", msg.sender)
            else:
                self.send_clue_message(msg.sender, 0)
            return

        # Visa när nästa ledtråd kommer
        m = Gazonk.re_nasta.search(msg.message)
        if m:
            current_time = time.time()
            if self.current_clue == -1:
                send_message("Ingen gazonk-omgång pågår just nu.", msg.sender)
                return
            elif current_time - self.time_last_action > GAZONK_CLUE_TIME:
                send_message("Nästa ledtråd borde redan ha sänts, tjata på gazonk!", msg.sender)
                return
            else:
                next_clue_time = self.time_last_action + GAZONK_CLUE_TIME - current_time
                message = "Det är %d timmar och %d minuter kvar till nästa ledtråd" % \
                          (int(next_clue_time/3600), int(next_clue_time/60))
                send_message(message, msg.sender)
                return

        # Saker som alla utom gazonk får göra:
        if self.person_no != msg.sender:
            if self.current_clue == -1:
                send_message("Ingen gazonk-omgång pågår just nu.", msg.sender)
                return
            # Har vi gissat rätt lösenord?
            m = Gazonk.re_gissa.match(msg.message)
            sm = msg.message.strip()

            guess = sm
            if m:
                guess = m.group(1)

            gm = Gazonk.re_gissning.search(guess)
            if not gm:
                send_message("Din gissning godkändes ej.\n\n" + \
                             "Ett lösenord innehåller enbart bokstäverna\n" + \
                             "a-z, å, ä, ö, samt är mellan 1 och %d bokstäver långt." % \
                             GAZ_PW_LENGTH, \
                             msg.sender)
                return

            # Lägg till gissningen i lite gissningsdatabaser.
            self.monthly.add_guess(guess, msg.sender)
            self.current_guesses.add(guess)
            self.per_clue_guesses[self.current_clue].add(guess)

            if guess == self.password:
                send_message("Grattis, Du gissade rätt!\nDu är nu ny gazonk!", msg.sender)
                gaz_name = kom.ReqGetUconfStat(conn, self.person_no).response().name
                new_gaz_name = kom.ReqGetUconfStat(conn, msg.sender).response().name
                mess_subject = "<Person %d: %s> gazonkar" % (self.person_no, gaz_name)
                mess_text = "<Person %d: %s> klarade lösenordet och är ny gazonk!" % \
                            (msg.sender, new_gaz_name)
                self.send_end_of_round_message(mess_subject, mess_text)
                self.reset()
                self.person_no = msg.sender
                self.set_last_action()
                return
            else:
                send_message(random.choice(wrong_guess_list), msg.sender)
                return

        # Detta kommando var inte begripligt
        send_message("Jag begriper inte vad du vill göra!", msg.sender)
        return

class MonthlyStats:
    def __init__(self):
        self.guesses = GuessDB()
        self.people = {}

    def reset(self):
        self.guesses.reset()
        self.people = {}

    def add_guess(self, guess, person):
        self.guesses.add(guess)
        #TODO add for the person too

# Liten klass för att hålla reda på ord.
class GuessDB:
    def __init__(self):
        self.db = {}
        self.count = 0

    def reset(self):
        self.db = {}
        self.count = 0

    def add(self, guess):
        self.count += 1
        if not self.db.has_key(guess):
            self.db[guess] = 1
        else:
            self.db[guess] += 1

    def create_string(self, max_nr = MAX_ENTRIES_GUESS_LIST):
        glist = zip(self.db.values(), self.db.keys())
        glist.sort()
        glist.reverse()

        guess_string = ""
        for (amount, guess) in glist[:max_nr]:
            guess_string += string.ljust(guess, min(GAZ_PW_LENGTH + 9, 60)) + \
                            " " + string.rjust(str(amount), 5) + "\n"
        if self.count == 0:
            guess_string += "Inga gissningar.\n" 
        elif self.count == 1:
            guess_string += "----------------------------\n"
            guess_string += "Sammanlagt 1 gissning.\n"
        else:
            guess_string += "----------------------------\n"
            guess_string += "Sammanlagt %d gissningar.\n" % self.count
        return guess_string

# Loggning
def log(txt):
    if LOG == 1:
        if txt[-1:] <> "\n":
            txt = txt + "\n"
        logfile.write(txt)
        logfile.flush()

def get_date_and_time():
    return time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(time.time()))

# Indentering
def indent(txt, spaces):
    lines = string.split(txt, "\n")
    lines = map(lambda line, prefix=" "*spaces: prefix + line, lines)
    return string.join(lines, "\n")

def send_message(message, recipient):
    recipient_name = kom.ReqGetUconfStat(conn, recipient).response().name
    log("%s: Meddelande till %s:" % (get_date_and_time(), recipient_name))
    log(indent(message, 2) + "\n")

    try:
        kom.ReqSendMessage(conn, recipient, message).response()
        kom.ReqUserActive(conn).response()
    except:
        log("Misslyckades med att skicka meddelande.")

#
# Huvudkod
#

# Öppna en logfil, kan vara bra att ha :-)
logfile = open(LOGFILE, "a")
log("Starting")

# Skapa en gazonk-information
if os.path.exists(DUMPFILE):
    gaz = cPickle.load(open(DUMPFILE))
else:
    gaz = Gazonk();

# Koppla upp sig, logga in och annat kul
log("Kopplar upp")
conn = kom.CachedConnection(KOMSERVER, port = KOMPORT)
log("Loggar in")
kom.ReqLogin(conn, KOMPERSON, KOMPASSWORD, INVISIBLE).response()
kom.ReqSetClientVersion(conn, CLIENTNAME, VERSION)
log("Gazonk!")

# Hantera meddelanden

conn.add_async_handler(kom.ASYNC_SEND_MESSAGE, gaz.parse_message)
kom.ReqAcceptAsync(conn, [kom.ASYNC_SEND_MESSAGE]).response()

while 1:
    select.select([conn.socket], [], [], MAX_SLEEP_TIME)
    conn.parse_present_data()
    gaz.check_clues()
    cPickle.dump(gaz, open(DUMPFILE, 'w'), DUMPBIN)
#    gaz.set_last_action()
